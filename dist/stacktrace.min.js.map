{"version":3,"sources":["stacktrace-gps.min.js","stack-generator.js","error-stack-parser.js","stacktrace.js"],"names":["root","factory","define","amd","exports","module","require","StackTraceGPS","SourceMap","ES6Promise","StackFrame","this","_createXMLHTTPObject","xmlhttp","XMLHttpFactories","XMLHttpRequest","ActiveXObject","i","length","e","_xdr","url","callback","errback","req","open","onerror","onreadystatechange","readyState","status","responseText","Error","send","_findFunctionName","source","lineNumber","columnNumber","line","m","commentPos","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","lines","split","code","maxLines","Math","min","indexOf","substr","exec","undefined","_ensureSupportedEnvironment","Object","defineProperty","create","_ensureStackFrameIsLegit","stackframe","TypeError","fileName","_findSourceMappingURL","_newLocationInfoFromSourceMap","rawSourceMap","args","loc","SourceMapConsumer","originalPositionFor","column","name","polyfill","Promise","opts","sourceCache","_get","location","resolve","reject","offline","bind","pinpoint","getMappedLocation","then","findFunctionName","guessedFunctionName","map","StackGenerator","backtrace","stack","maxStackSize","curr","arguments","callee","slice","call","push","test","toString","RegExp","$1","caller","ErrorStackParser","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","parse","error","stacktrace","parseOpera","match","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","locationParts","lastNumber","pop","possibleNumber","isNaN","parseFloat","isFinite","join","tokens","replace","functionName","filter","shift","message","parseOpera9","parseOpera11","parseOpera10","lineRE","result","len","argsRaw","functionCall","StackTrace","_merge","first","second","target","forEach","obj","prop","hasOwnProperty","_isShapedLikeParsableError","err","_options","get","fromError","generateArtificially","stackframes","all","sf","resolveOriginal","_","stackFrames","instrument","fn","thisArg","__stacktraceOriginalFn","instrumented","apply","deinstrument"],"mappings":"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","file":"stacktrace.min.js","sourcesContent":["(function(root,factory){\"use strict\";if(typeof define===\"function\"&&define.amd){define(\"stacktrace-gps\",[\"source-map\",\"es6-promise\",\"stackframe\"],factory)}else if(typeof exports===\"object\"){module.exports=factory(require(\"source-map/lib/source-map/source-map-consumer\"),require(\"es6-promise\"),require(\"stackframe\"))}else{root.StackTraceGPS=factory(root.SourceMap,root.ES6Promise,root.StackFrame)}})(this,function(SourceMap,ES6Promise){\"use strict\";ES6Promise.polyfill();var Promise=ES6Promise.Promise;function _createXMLHTTPObject(){var xmlhttp;var XMLHttpFactories=[function(){return new XMLHttpRequest},function(){return new ActiveXObject(\"Microsoft.XMLHTTP\")}];for(var i=0;i<XMLHttpFactories.length;i++){try{xmlhttp=XMLHttpFactories[i]();_createXMLHTTPObject=XMLHttpFactories[i];return xmlhttp}catch(e){}}}function _xdr(url,callback,errback){var req=_createXMLHTTPObject();req.open(\"get\",url);req.onerror=errback;req.onreadystatechange=function onreadystatechange(){if(req.readyState===4){if(req.status>=200&&req.status<400){return callback(req.responseText)}else{errback(new Error(\"Unable to retrieve \"+url))}}};req.send()}function _findFunctionName(source,lineNumber,columnNumber){var reFunctionDeclaration=/function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;var reFunctionExpression=/['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;var reFunctionEvaluation=/['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;var lines=source.split(\"\\n\");var code=\"\",line,maxLines=Math.min(lineNumber,20),m,commentPos;for(var i=0;i<maxLines;++i){line=lines[lineNumber-i-1];commentPos=line.indexOf(\"//\");if(commentPos>=0){line=line.substr(0,commentPos)}if(line){code=line+code;m=reFunctionExpression.exec(code);if(m&&m[1]){return m[1]}m=reFunctionDeclaration.exec(code);if(m&&m[1]){return m[1]}m=reFunctionEvaluation.exec(code);if(m&&m[1]){return m[1]}}}return undefined}function _ensureSupportedEnvironment(){if(typeof Object.defineProperty!==\"function\"||typeof Object.create!==\"function\"){throw new Error(\"Unable to consume source maps in older browsers\")}}function _ensureStackFrameIsLegit(stackframe){if(typeof stackframe!==\"object\"){throw new TypeError(\"Given StackFrame is not an object\")}else if(typeof stackframe.fileName!==\"string\"){throw new TypeError(\"Given file name is not a String\")}else if(typeof stackframe.lineNumber!==\"number\"||stackframe.lineNumber%1!==0||stackframe.lineNumber<1){throw new TypeError(\"Given line number must be a positive integer\")}else if(typeof stackframe.columnNumber!==\"number\"||stackframe.columnNumber%1!==0||stackframe.columnNumber<0){throw new TypeError(\"Given column number must be a non-negative integer\")}return true}function _findSourceMappingURL(source){var m=/\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)$/.exec(source);if(m&&m[1]){return m[1]}else{throw new Error(\"sourceMappingURL not found\")}}function _newLocationInfoFromSourceMap(rawSourceMap,args,lineNumber,columnNumber){var loc=new SourceMap.SourceMapConsumer(rawSourceMap).originalPositionFor({line:lineNumber,column:columnNumber});return new StackFrame(loc.name,args,loc.source,loc.line,loc.column)}return function StackTraceGPS(opts){if(!(this instanceof StackTraceGPS)){return new StackTraceGPS(opts)}opts=opts||{};this.sourceCache=opts.sourceCache||{};this._get=function _get(location){return new Promise(function(resolve,reject){if(this.sourceCache[location]){resolve(this.sourceCache[location])}else if(opts.offline){reject(new Error(\"Cannot make network requests in offline mode\"))}else{_xdr(location,function(source){this.sourceCache[location]=source;resolve(source)}.bind(this),reject)}}.bind(this))};this.pinpoint=function StackTraceGPS$$pinpoint(stackframe){return this.getMappedLocation(stackframe).then(this.findFunctionName.bind(this))};this.findFunctionName=function StackTraceGPS$$findFunctionName(stackframe){return new Promise(function(resolve,reject){_ensureStackFrameIsLegit(stackframe);this._get(stackframe.fileName).then(function getSourceCallback(source){var guessedFunctionName=_findFunctionName(source,stackframe.lineNumber,stackframe.columnNumber);resolve(new StackFrame(guessedFunctionName,stackframe.args,stackframe.fileName,stackframe.lineNumber,stackframe.columnNumber))},reject)}.bind(this))};this.getMappedLocation=function StackTraceGPS$$getMappedLocation(stackframe){return new Promise(function(resolve,reject){_ensureSupportedEnvironment();_ensureStackFrameIsLegit(stackframe);this._get(stackframe.fileName).then(function(source){this._get(_findSourceMappingURL(source)).then(function(map){var lineNumber=stackframe.lineNumber;var columnNumber=stackframe.columnNumber;resolve(_newLocationInfoFromSourceMap(map,stackframe.args,lineNumber,columnNumber))},reject)[\"catch\"](reject)}.bind(this),reject)[\"catch\"](reject)}.bind(this))}}});\n//@ sourceMappingURL=stacktrace-gps.js.map","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n    if (typeof define === 'function' && define.amd) {\n        define('stack-generator', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.StackGenerator = factory(root.StackFrame);\n    }\n}(this, function (StackFrame) {\n    return {\n        backtrace: function StackGenerator$$backtrace(opts) {\n            var stack = [];\n            var maxStackSize = 10;\n\n            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n                maxStackSize = opts.maxStackSize;\n            }\n\n            var curr = arguments.callee;\n            while (curr && stack.length < maxStackSize) {\n                var args = [].slice.call(curr['arguments']);\n                if (/function(?:\\s+([\\w$]+))?\\s*\\(/.test(curr.toString())) {\n                    stack.push(new StackFrame(RegExp.$1 || undefined, args));\n                } else {\n                    stack.push(new StackFrame(undefined, args));\n                }\n\n                try {\n                    curr = curr.caller;\n                } catch (e) {\n                    break;\n                }\n            }\n            return stack;\n        }\n    };\n}));\n","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /\\s+at /;\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         * @param error {Error}\n         * @return Array[StackFrame]\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack && error.stack.match(FIREFOX_SAFARI_STACK_REGEXP)) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        /**\n         * Separate line and column numbers from a URL-like string.\n         * @param urlLike String\n         * @return Array[String]\n         */\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            var locationParts = urlLike.split(':');\n            var lastNumber = locationParts.pop();\n            var possibleNumber = locationParts[locationParts.length - 1];\n            if (!isNaN(parseFloat(possibleNumber)) && isFinite(possibleNumber)) {\n                var lineNumber = locationParts.pop();\n                return [locationParts.join(':'), lineNumber, lastNumber];\n            } else {\n                return [locationParts.join(':'), lastNumber, undefined];\n            }\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            return error.stack.split('\\n').slice(1).map(function (line) {\n                var tokens = line.replace(/^\\s+/, '').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop().replace(/[\\(\\)\\s]/g, ''));\n                var functionName = (!tokens[0] || tokens[0] === 'Anonymous') ? undefined : tokens[0];\n                return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2]);\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            return error.stack.split('\\n').filter(function (line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP);\n            }, this).map(function (line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.shift() || undefined;\n                return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2]);\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(undefined, undefined, match[2], match[1]));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(match[3] || undefined, undefined, match[2], match[1]));\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            return error.stack.split('\\n').filter(function (line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n                    !line.match(/^Error created at/);\n            }, this).map(function (line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ? undefined : argsRaw.split(',');\n                return new StackFrame(functionName, args, locationParts[0], locationParts[1], locationParts[2]);\n            }, this);\n        }\n    };\n}));\n\n","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace', ['error-stack-parser', 'stack-generator', 'stacktrace-gps'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n    } else {\n        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n    }\n}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n    var _options = {\n        filter: function (stackframe) {\n            // Filter out stackframes for this library by default\n            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n        }\n    };\n\n    /**\n     * Merge 2 given Objects. If a conflict occurs the second object wins.\n     * Does not do deep merges.\n     * @param first Object\n     * @param second Object\n     * @returns new Object merged first and second\n     * @private\n     */\n    function _merge(first, second) {\n        var target = {};\n\n        [first, second].forEach(function (obj) {\n            for (var prop in obj) {\n                if (obj.hasOwnProperty(prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n            return target;\n        });\n\n        return target;\n    }\n\n    function _isShapedLikeParsableError(err) {\n        return err.stack || err['opera#sourceloc'];\n    }\n\n    return {\n        /**\n         * Get a backtrace from invocation point.\n         * @param opts Options Object\n         * @return Array[StackFrame]\n         */\n        get: function StackTrace$$get(opts) {\n            try {\n                // Error must be thrown to get stack in IE\n                throw new Error();\n            } catch (err) {\n                if (_isShapedLikeParsableError(err)) {\n                    return this.fromError(err, opts);\n                } else {\n                    return this.generateArtificially(opts);\n                }\n            }\n        },\n\n        /**\n         * Given an error object, parse it.\n         * @param error Error object\n         * @param opts Object for options\n         * @return Array[StackFrame]\n         */\n        fromError: function StackTrace$$fromError(error, opts) {\n            opts = _merge(_options, opts);\n            return new Promise(function (resolve) {\n                var stackframes = ErrorStackParser.parse(error);\n                if (typeof opts.filter === 'function') {\n                    stackframes = stackframes.filter(opts.filter);\n                }\n                resolve(Promise.all(stackframes.map(function (sf) {\n                    return new Promise(function (resolve) {\n                        function resolveOriginal(_) {\n                            resolve(sf);\n                        }\n\n                        new StackTraceGPS(opts).pinpoint(sf)\n                            .then(resolve, resolveOriginal)['catch'](resolveOriginal);\n                    });\n                })));\n            }.bind(this));\n        },\n\n        /**\n         * Use StackGenerator to generate a backtrace.\n         * @param opts Object options\n         * @returns Array[StackFrame]\n         */\n        generateArtificially: function StackTrace$$generateArtificially(opts) {\n            opts = _merge(_options, opts);\n            var stackFrames = StackGenerator.backtrace(opts);\n            if (typeof opts.filter === 'function') {\n                stackFrames = stackFrames.filter(opts.filter);\n            }\n            return Promise.resolve(stackFrames);\n        },\n\n        /**\n         * Given a function, wrap it such that invocations trigger a callback that\n         * is called with a stack trace.\n         *\n         * @param {Function} fn to be instrumented\n         * @param {Function} callback function to call with a stack trace on invocation\n         * @param {Function} errback optional function to call with error if unable to get stack trace.\n         * @param {Object} thisArg optional context object (e.g. window)\n         */\n        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                // Already instrumented, return given Function\n                return fn;\n            }\n\n            var instrumented = function StackTrace$$instrumented() {\n                try {\n                    this.get().then(callback, errback)['catch'](errback);\n                    fn.apply(thisArg || this, arguments);\n                } catch (e) {\n                    if (_isShapedLikeParsableError(e)) {\n                        this.fromError(e).then(callback, errback)['catch'](errback);\n                    }\n                    throw e;\n                }\n            }.bind(this);\n            instrumented.__stacktraceOriginalFn = fn;\n\n            return instrumented;\n        },\n\n        /**\n         * Given a function that has been instrumented,\n         * revert the function to it's original (non-instrumented) state.\n         *\n         * @param fn {Function}\n         */\n        deinstrument: function StackTrace$$deinstrument(fn) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot de-instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                return fn.__stacktraceOriginalFn;\n            } else {\n                // Function not instrumented, return original\n                return fn;\n            }\n        }\n    };\n}));\n"],"sourceRoot":"/source/"}